스프링 AOP
=======================

목차 
-----------------------
- AOP 소개 
- 스프링에서의 AOP 
- XML 스키마 기반 AOP 퀵 스타트 
- XML 스키마 기반의 POJO 클래스를 이용한 AOP 구현 
- @Aspect 애노테이션 기반 AOP 퀵 스타트 
- @Aspect 애노테이션을 이용한 AOP 
- JoinPoint 사용 
- 타입을 이용한 파라미터 접근 
- AOP 프록시 객체 생성 방식 설정 
- AspectJ의 Pointcut 표현식 
- Advice 적용 순서

## 1. AOP 소개
Aspect Oriented Programming, 줄여서 AOP는 문제를 바라보는 관점을 기준으로 프로그래밍 하는 기법을 말한다. AOP는 문제를 해결하기 위한 핵심 관심 사항과 전체에 적용되는 공통 관심 사항을 기준으로 프로그래밍 함으로써 공통 모듈을 여러 코드에 쉽게 적용할 수 있도록 도와준다.

AOP를 구현하는 방법에는 다양한 방법이 존재하지만, 기본적인 개념은 공통 관심 사항을 구현한 코드를 핵심 로직을 구현한 코드 안에 삽입하는 것이다.

AOP 기법에서는 핵심 로직을 구현한 코드에서 공통 기능을 직접적으로 호출하지 않고 핵심 로직을 구현한 코드를 컴파일하거나 컴파일 된 클래스를 로딩하거나, 또는 로딩한 클래스의 객체를 생성할 때 AOP가 적용되어 핵심 로직 구현 코드 안에 공통 기능이 삽입된다.

AOP 프로그래밍에서는 AOP 라이브러리가 공통 기능을 알맞게 삽입해주기 때문에 개발자는 게시글 쓰기나 목록 읽기와 같은 핵심 로직을 구현할 때 트랜젝션 보안이나 보안 검사와 같은 공통 기능을 처리하기 위한 코드를 핵심 로직에 삽입할 필요가 없다.

핵심 로직을 구현한 코드에 공통 기능 관련 코드가 포함되어 있지 않으므로 적용해야 할 공통 기능이 변경되더라도 핵심 로직 구현 코드를 변경할 필요가 없다. 단지, 공통 기능 코드를 변경한 뒤 핵심 로직 구현 코드에 적용만 하면 된다.

- 1.1 AOP 용어

AOP는 다양한 용어를 소개하고 있다.

|  <center>용어</center> |  <center>의미</center> | 
|:--------|:--------|
|**Joinpoint** | Advice를 적용 가능한 지점을 의미한다. 메서드 호출, 필드 값 변경 등이 Joinpoint에 해당한다. |
|**Pointcut** | Joinpoint의 부분 집합으로서 실제로 Advice가 적용되는 Joinpoint를 나타낸다. 스프링에서는 정규 표현식이나 AspectJ의 문법을 이용하여 Pointcut을 정의할수 있다.  |
|**Advice** | 언제 공통 관심 기능을 핵심 로직에 적용할 지를 정의하고 있다. 예를 들어, '메서드를 호출하기 전'(언제)에 '트랜젝션시작'(공통기능) 기능을 적용한다는 것을 정의하고 있다.  |
|**Weaving** | Advice를 핵심 로직 코드에 적용하는 것을 weaving이라고 한다. | 
|**Aspect** | 여러 객체에 공통으로 적용되는 기능을 Aspect라고 한다. 트랜젝션이나 보안 등이 Aspect의 좋은 예이다. |

- 1.2 세가지 Weaving 방식

Advice를 Weaving하는 방식에는 다음과 같이 세 가지 방식이 존재한다.

-컴파일 시에 Weaving 하기

-클래스 로딩 시에 Weaving 하기

-런타임 시에 Weaving 하기

컴파일 시에 코드를 삽입하는 방법은 AspectJ에서 사용하는 방식이다. 컴파일 방식에서는 핵심 로직을 구현한 자바 소스 코드를 컴파일 할 때, 알맞은 위치에 공통 코드를 삽입하면, 컴파일 결과 AOP가 적용된 클래스 파일이 생성된다.
컴파일 방식을 제공하는 AOP 도구는 공통 코드를 알맞은 위치에 삽입할 수 있도록 도와주는 컴파일러나 IDE를 함께 제공한다.

클래스를 로딩할 때에 AOP를 적용할 수도 있다. AOP 라이브러리는 JVM이 클래스를 로딩할 때 클래스 정보를 변경할 수 있는 에이전트를 제공한다. 이 에이전트는 로딩한 클래스의 바이너리 정보를 변경하여 알맞은 위치에 공통 코드를 삽입한 새로운 클래스 바이너리 코드를 사용하도록 한다. 즉, 원본 클래스 파일은 변경하지 않고 클래스를 로딩할 때에 JVM이 변경된 바이트코드를 사용하도록 함으로써 AOP를 적용한다. AspectJ는 컴파일 방식과 더불어 클래스 로딩 방식을 함께 지원하고 있다.

런타임 시에 AOP를 적용할 때에는 소스 코드나 클래스 정보 자체를 변경하지 않는다. 대신, 프록시를 이용하여 AOP를 적용한다.프록시 기반의 AOP는 핵심 로직을 구현한 객체에 직접 접근하는 것이 아니라 중간에 프록시를 생성하여 프록시를 통해서 핵심 로직을 구현한 객체에 접근하게 된다.

이때, 프록시는 핵심 로직을 실행하기 전 또는 후에 공통 기능을 적용하는 방식으로 AOP를 구현하게 된다. 프록시 기반에서는 메서드가 호출될 때에만 Advice를 적용할 수 있기 때문에 필드 값 변경과 같은 Joinpoint에 대해서는 적용할 수 없는 한계가 있다.

## 2. 스프링에서의 AOP 

스프링은 자체적으로 프록시 기반의 AOP를 지원하고 있다. 따라서, 스프링 AOP는 메서드 호출 Joinpoint만을 지원한다. 필드 값 변경과 같은 Joinpoint를 사용하고 싶다면 AspectJ와 같이 다양한 Joinpoint를 지원하는 AOP 도구를 사용해야 한다.

스프링은 완전한 AOP 기능을 제공하는 것이 목적이 아니라 엔터프라이즈 어플리케이션을 구현하는 데 필요한 기능을 제공하는 것을 목적으로 하고 있다.

스프링 AOP의 또 다른 특징은 자바 기반이라는 점이다. AspectJ는 Aspect를 위한 별도의 문법을 제공하고 있는 반면에 스프링은 별도의 문법을 익힐 필요 없이 자바 언어만을 이용하면 된다.

스프링은 세 가지 방식으로 AOP를 구현할수 있도록 하고 있다.

- XML 스키마 기반의 POJO 클래스를 이용한 AOP 구현
- AspectJ에서 정의한 @Aspect 애노테이션 기반의 AOP 구현
- 스프링 API를 이용한 AOP 구현

어떤 방식을 사용하더라도 내부적으로는 프록시를 이용하여 AOP가 구현되므로 메서드 호출에 대해서만 AOP를 적용할 수 있다는 것에 유의하자. (즉, AspectJ에서 정의한 @Aspect 애노테이션을 사용하더라도 메서드 호출과 관련된 Pointcut만 사용가능하다.)

>개발자가 직접 스프링 AOP API를 사용해서 AOP를 구현하는 경우는 많지 않으며, 일반적으로 XML스키마를 이용하거나 @Aspect 애노테이션을 이용해서 AOP를 >구현한다. 스프링 AOP API를 이용하는 방식은 (http://goo.gl/P7ulvD) 를 참조바람

- 프록시를 이용한 AOP 구현
스프링이 프록시를 이용해서 AOP를 구현하고 있다. 스프링은 Aspect의 적용대상(target)이 되는 객체에 대한 프록시를 만들어 제공하며, 대상 객체를 사용하는 코드는 대상 객체에 직접 접근하지 않고 프록시를 통해서 간접적으로 접근하게 된다. 이과정에서 프록시는 공통 기능을 실행한 뒤 대상 객체의 실제 메서드를 호출하거나 또는 대상 객체의 실제 메서드를 호출한 후에 공통 기능을 실행하게 된다.

대상 객체는 결국 스프링 빈 객체가 되는데, 스프링은 설정 정보를 이용해서 어떤 빈 객체에 Aspect를 적용할지의 여부를 지정한다. 스프링 컨테이너를 초기화 하는 과정에서 설정 정보에 지정한 빈 객체에 대한 프록시 객체를 생성하고, 원본 빈 객체 대신에 프록시 객체를 사용학도록 한다. 프록시 객체를 생성하는 방식은 대상 객체가 인터페이스를 구현하고 있느냐 없느냐 여부에 따라 달라진다. 대상 객체가 인터페이스를 구현하고 있다면, 스프링은 자바 리플렉션 API가 제공하는 java.lang.reflect.Proxy 를 이용하여 프록시 객체를 생성한다. 이때 생성된 프록시 객체는 대상 객체와 동일한 인터페이스를 구현하게 되며, 클라이언트 인터페이스를 통해서 필요한 메서드를 호출하게 된다. 하지만 인터페이스를 기반으로 프록시 객체를 생성하기 때문에 인터페이스에 정의 되어 있지 않은 메서드에 대해서는 AOP가 적용되지 않는 점에 유의해야 한다.

대상 객체가 인터페이스를 구현하고 있지 않다면, 스프링은 CGLIB를 이용하여 클래스에 대한 프록시 객체를 생성한다. CGLIB는 대상 클래스를 상속받아 프록시를 구현한다. 따라서, 대상 클래스가 final인 경우 프록시를 생성할 수 없으며, final인 메서드에 대해서는 AOP를 적용할 수 없게 된다.

>많은 프레임워크가 개발 라이브러리가 런타임에 객체를 생성하기 위해 CGLIB를 사용하고 있다. 이들을 함께 사용하다보면 CGLIB 버전 충돌 문제 등이 발생  >할 수 있는대, 이런 충돌 문제가 발생하지 않도록 하기 위해 프레임워크나 라이브러리에 CGLIB의 패키지 구조를 변경해서 포함시키는 경우가 증가하고 있다. >스프링 4 버전도 패키지 구조를 변경한 CGLIB 클래스를 포함하고 있기 때문에 별도 CGLIB 모듈을 필요로 하지 않는다.

- 구현 가능한 Advice 종류

스프링은 프록시를 이용해서 메서드를 호출할 때 Aspect를 적용하기 때문에 구현 가능한 Advice 종류는 다음과 같다.

|  <center>종류</center> |  <center>설명</center> | 
|:--------|:--------|
|**Before Advice** | 대상 객체의 메서드 호출 전에 공통 기능을 실행한다. |
|**After Returning Advice** | 대상 객체의 메서드가 익셉션 없이 실행된 이후에 공통 기능을 실행한다.  |
|**After Throwing Advice** | 대상 객체의 메서드를 실행하는 도중 익셉션이 발생한 경우에 공통 기능을 실행한다.  |
|**After Advice** | 대상 객체의 메서드를 실행하는 도중에 익셉션이 발생했는지의 여부에 상관없이 메서드 실행 후 공통 기능을 실행한다. (try-catch-finally의 finally 블록과 비슷하다) | 
|**Around Advice** | 대상 객체의 메서드 실행 전, 후 또는 익셉션 발생 시점에 공통 기능을 실행하는데 사용된다.

이들 AOP 중에서 범용적으로 사용되는 것은 Around Advice인데, 그 이유는 대상 객체의 메서드를 실행하기 전/후에 원하는 기능을 삽입할수 있기 때문이다. 이런 이유로 캐시기능, 모니터링기능과 같은 Aspect를 구현할 때에는 Around Advice를 주로 이용하게 된다. |


## 3. XML 스키마 기반 AOP 퀵 스타트
XML 스키마를 이용해서 AOP를 구현하는 과정은 다음과 같다.

스프링 AOP를 사용하기 위한 의존을 추가한다.
공통 기능을 제공할 클래스를 구현한다.
XML 설정 파일에 aop:config를 이용해서 Aspect를 설정한다. Advice를 어떤 Pointcut에 적용할지를 지정하게 된다.
pom.xml의 dependency에 spring-aop와 aspectjweaver를 추가해주자.




  
  ```java
public void Profiler{
	public Object trace(ProceedingJoinPoint joinPoint) throws Throwable{
		String sinatureString = joinPoint.getSignature().toShortString();
		System.out.println(signatureString + " 시작 ");
		long start = System.currentTimeMillis();
		try{
			Object result = joinPoint.proceed();
			return result;
		} finally{
			long finish = System.currentTimeMillis();
			System.out.println(signatureString + " 종료");
			System.out.println(signatureString + " 실행시간 : " + (finish - start) + "ms");
		}

	}
}
  ```
  

## 2. 빈 객체 범위(scope)
: 스프링의 빈은 범위(scope)를 갖는데 주요 범위에는 다음의 두 가지가 있다.

-싱글톤(singleton) 범위

-프로토타입(prototype) 범위



## 참고내용
- 서적 : 웹 개발자를 위한 Spring 4.0 프로그래밍 (최범균 저자)
- 참고예제소스 : https://github.com/madvirus/spring4


